<!doctype html><html lang=en><head><title>Implementing a Merkle tree in Python ::
Yet Another Random Memoir</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Unless you&amp;rsquo;ve been living under a rock for the past few years you have probably heard of Bitcoin, the decentralized, peer-to-peer, public, trustless, cash system protocol. Regardless of whether or not you think bitcoin&amp;rsquo;s current valuation is in a bubble or worse that it&amp;rsquo;s a Ponzi scheme, it&amp;rsquo;s undeniable that the protocol solves a real and old problem in distributed computing, a.k.a the Byzantine&amp;rsquo;s General Problem. One of the underlying data structures ensuring the immutability of the blockchain is the Merkle tree."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://trebaud.github.io/posts/merkle-tree/><link rel=stylesheet href=https://trebaud.github.io/assets/style.css><link rel=stylesheet href=https://trebaud.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://trebaud.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://trebaud.github.io/img/favicon.png><link href=https://trebaud.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://trebaud.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://trebaud.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://trebaud.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://trebaud.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://trebaud.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trebaud.github.io/"><meta name=twitter:title content="Implementing a Merkle tree in Python"><meta name=twitter:description content="Build a Merkle tree in Python"><meta property="og:title" content="Implementing a Merkle tree in Python"><meta property="og:description" content="Build a Merkle tree in Python"><meta property="og:type" content="article"><meta property="og:url" content="https://trebaud.github.io/posts/merkle-tree/"><meta property="og:image" content="https://trebaud.github.io/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-06T00:00:00-05:00"><meta property="article:modified_time" content="2018-01-06T00:00:00-05:00"></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>üè† Home</a></li><li><a href=/posts>üìù All posts</a></li><li><a href=/about>üë®‚Äçüíª About</a></li><li><a href=/tags>üîç Tags</a></li><li><a href=/neck-visualizer>üé∏</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>üè† Home</a></li><li><a href=/posts>üìù All posts</a></li><li><a href=/about>üë®‚Äçüíª About</a></li><li><a href=/tags>üîç Tags</a></li><li><a href=/neck-visualizer>üé∏</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Implementing a Merkle tree in Python</h1><div class=post-meta><span class=post-date>2018-01-06</span></div><span class=post-tags><a href=https://trebaud.github.io/tags/development/>#development</a>&nbsp;
<a href=https://trebaud.github.io/tags/bitcoin/>#bitcoin</a>&nbsp;</span><div class=post-content><p>Unless you&rsquo;ve been living under a rock for the past few years you have probably heard of Bitcoin, the decentralized, peer-to-peer, public, trustless, cash system protocol. Regardless of whether or not you think bitcoin&rsquo;s current valuation is in a bubble or worse that it&rsquo;s a Ponzi scheme, it&rsquo;s undeniable that the protocol solves a real and old problem in distributed computing, a.k.a the <a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance#Byzantine_Generals'_Problem">Byzantine&rsquo;s General Problem</a>. One of the underlying data structures ensuring the immutability of the blockchain is the Merkle tree.</p><p>A Merkle tree is a binary tree in which each leaf node is a hash of a block of data and each internal node is a hash of its children. In the bitcoin protocol it ensures the immutability of the set of transactions by taking the hash of each data transaction and generating a single unique root hash representing the hash of the entire set.</p><p><img src=/img/merkletree.png alt=merkle-tree></p><p>In this post we&rsquo;ll look at a possible implementation of a Merkle tree in python using the typing module. If you&rsquo;re not familiar with typing you can take a look at my last <a href=%7B%7Bsite.url%7D%7D/2017/12/27/typing-python.html>post</a> where I go a little more in depth on how to use this module.
The API for the Merkle tree data structure is very straightforward and consists of a single method which exposes the root hash of the tree. The constructor takes a list of objects from which we wish to build our tree.</p><p>Our Node class stores its hash and a reference to the left and right child nodes. We&rsquo;ll add two static methods to do the hashing using the SHA-256 algorithm. We&rsquo;ll apply the hashing two times for an extra level of security. Because of the way the Merkle tree is structured we need an even number of leaf nodes to build our tree. If we have an odd number of data blocks then we just hash the last one two times, duplicating the last leaf node.</p><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> List
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> typing
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> hashlib
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, left, right, value: str)<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>left: Node <span style=color:#f92672>=</span> left
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>right: Node <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hash</span>(val: str)<span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> hashlib<span style=color:#f92672>.</span>sha256(val<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#39;utf-8&#39;</span>))<span style=color:#f92672>.</span>hexdigest()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>doubleHash</span>(val: str)<span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Node<span style=color:#f92672>.</span>hash(Node<span style=color:#f92672>.</span>hash(val))
</span></span></code></pre></div><p>Then the Merkle tree class itself comprised of two methods for recursively building the tree, two others for printing the nodes in prefix order and the one we mentionned earlier for getting the root hash.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MerkleTree</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, values: List[str])<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__buildTree(values)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__buildTree</span>(self, values: List[str])<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        leaves: List[Node] <span style=color:#f92672>=</span> [Node(<span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>, Node<span style=color:#f92672>.</span>doubleHash(e)) <span style=color:#66d9ef>for</span> e <span style=color:#f92672>in</span> values]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(leaves) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            leaves<span style=color:#f92672>.</span>append(leaves[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:][<span style=color:#ae81ff>0</span>]) <span style=color:#75715e># duplicate last elem if odd number of elements</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>root: Node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__buildTreeRec(leaves)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__buildTreeRec</span>(self, nodes: List[Node])<span style=color:#f92672>-&gt;</span> Node:
</span></span><span style=display:flex><span>        half: int <span style=color:#f92672>=</span> len(nodes) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(nodes) <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Node(nodes[<span style=color:#ae81ff>0</span>], nodes[<span style=color:#ae81ff>1</span>], Node<span style=color:#f92672>.</span>doubleHash(nodes[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>value <span style=color:#f92672>+</span> nodes[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>value))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        left: Node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__buildTreeRec(nodes[:half])
</span></span><span style=display:flex><span>        right: Node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__buildTreeRec(nodes[half:])
</span></span><span style=display:flex><span>        value: str <span style=color:#f92672>=</span> Node<span style=color:#f92672>.</span>doubleHash(left<span style=color:#f92672>.</span>value <span style=color:#f92672>+</span> right<span style=color:#f92672>.</span>value)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Node(left, right, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>printTree</span>(self)<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__printTreeRec(self<span style=color:#f92672>.</span>root)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__printTreeRec</span>(self, node)<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node <span style=color:#f92672>!=</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            print(node<span style=color:#f92672>.</span>value)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>__printTreeRec(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>__printTreeRec(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getRootHash</span>(self)<span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>root<span style=color:#f92672>.</span>value
</span></span></code></pre></div><p>We can then test our data structure by sending in a list of strings and getting its corresponding merkle tree root hash.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test</span>()<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    elems <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;Hello&#34;</span>, <span style=color:#e6db74>&#34;mister&#34;</span>, <span style=color:#e6db74>&#34;Merkle&#34;</span>]
</span></span><span style=display:flex><span>    mtree <span style=color:#f92672>=</span> MerkleTree(elems)
</span></span><span style=display:flex><span>    print(mtree<span style=color:#f92672>.</span>getRootHash())
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>~$ python3.6 merkletree.py
</span></span><span style=display:flex><span>8617d7a42c4ef170227e97fc407a9af29e1d52db4a0dcff56a039fd16cde0f69
</span></span></code></pre></div><p>That&rsquo;s it! Feel free to try this code and improve it at will.</p><p>Bye for now!</p></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></a><div class=copyright><span>¬© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://trebaud.github.io/assets/main.js></script>
<script src=https://trebaud.github.io/assets/prism.js></script></div></body></html>